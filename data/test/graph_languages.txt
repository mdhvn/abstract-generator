Specifying Graph Languages with Type Graphs Andrea Corradini1, Barbara K¬onig2, and Dennis Nolte2 1 Universit`a di Pisa, Italy andrea@di.unipi.it 2 Universit¬at Duisburg-Essen, Germany {barbara koenig,dennis.nolte}@uni-due.de Abstract. We investigate three formalisms to specify graph languages, i.e. sets of graphs, based on type graphs. First, we are interested in (pure) type graphs, where the corresponding language consists of all graphs that can be mapped homomorphically to a given type graph. In this context, we also study languages specified by restriction graphs and their relation to type graphs. Second, we extend this basic approach to a type graph logic and, third, to type graphs with annotations. We present decidability results and closure properties for each of the formalisms. 1 Introduction Formal languages in general and regular languages in particular play an important role in computer science. They can be used for pattern matching, parsing, verification and in many other domains. For instance, verification approaches such as reachability checking, counterexample-guided abstraction refinement[5] and non-termination analysis [10] could be directly adapted to graph transformationsystems ifonehad agraph specificationformalismwith suitableclosure properties, computable pre-and postconditions and inclusion checks. Inclusion checks are also important for checking when a fixpoint iteration sequence stabilizes. While regular languages for words and trees are well-understood and can be used efficiently and successfully in applications, the situation is less satisfactory when itcomestographs.Althoughthework ofCourcelle[8]presentsanaccepted notion of recognizable graph languages, equivalent to regular languages, this is oftennot useful inpractice,duetothesheersizeof theresultinggraph automata. Otherformalisms,such asapplicationconditions[20,12]andfirst-orderorsecondorder logics, feature more compact descriptions, but there are problems with expressiveness, undecidability issues or unsatisfactory closureproperties.3 Hence, we believe that it is important to study and compare specification formalisms(i.e.,automata,grammarsandlogics)thatallowtospecifypotentially infinite sets of graphs. In our opinion there is no one-fits-all solution, but we believe that specification mechanisms should be studied and compared more extensively. 3 A more detailed overview over related formalisms is given in the conclusion (Section 6). Inthispaper we study specificationformalismsbased ontypegraphs, where a typegraph T represents allgraphs that canbe mappedhomomorphically to T , potentiallytakingintoaccountsomeextraconstraints.Typegraphsarecommon in graph rewriting [6,21]. Usually, one assumes that all items, i.e., rules and graphs to be rewritten, are typed, introducing constraints on the applicability of rules.Hence,typegraphsare inaway seenasaformoflabelling.This isdifferent fromourpointof view,wheregraphs(and rules) are Ð apriori Ðuntyped(but labeled) and type graphs are simply a means to represent sets of graphs. Therearevariousreasonsforstudying typegraphs: first,they arereasonably simple with many positive decidability results and they have not yet been extensively studied from theperspective of specification formalisms. Second, other specification mechanisms Ð especially those used in connection with verification and abstract graph transformation [19,23,24] Ð are based on type graphs: abstractgraphsarebasicallytypegraphswith extra annotations.Third, while not being asexpressiveasrecognizablegraph languages,they retainanice intuition from regular languages: given a finite state automaton M one can think of the language of M as the set of all string graphs that can be mapped homomorphically to M (respectinginitial and final states). We infactstudy threedifferentformalismsbased ontypegraphs: first,pure type graphs T , where the language consists simply of all graphs that can be mapped to T .We alsodiscuss the connectionbetween typegraph and restriction graphlanguages.Then, inordertoobtaina languagewithbetterbooleanclosure properties,westudytypegraphlogic, which consistsoftypegraphsenriched with boolean connectives (negation, conjunction, disjunction). Finally, we consider annotated type graphs, where the annotations constrain the number of items mapped to a specific node or edge, somewhat similar to the proposals from abstract graph rewriting mentioned above. In all three cases we are interested in closure properties and in decidability issues(suchdecidability ofthemembership,emptinessand inclusionproblems) and in expressiveness. Proofs for all the results can be found in Appendix A. 2 Preliminaries We first introducegraphsandgraph morphisms.Inthecontextof thispaperwe use edge-labeled, directed graphs. Definition 1 (Graph). Let . be a fixed set of edge labels. A .-labeled graph is a tuple G = hV, E, src, tgt, labi, where V is a finite set of nodes, E is a finite set of edges, src, tgt: E . V assign to each edge a source and a target node, and lab: E . . is a labeling function. We will denote, for a given graph G, its components by VG, EG, srcG, tgtG and labG, unless otherwise indicated. Definition 2 (Graph morphism). Let G, G . be two .-labeledgraphs. A graph morphism .: G . G . consists of two functions .V : VG . VG. and .E : EG . 2 EG. , such that for each edge e . EG it holds that srcG. (.E(e))= .V (srcG(e)), tgtG. (.E (e)) = .V (tgtG(e)) and labG. (.E (e)) = labG(e). If . is both injective and surjective it is called an isomorphism. We will oftendropthe subscripts V, E and write . instead of .V , .E .We will consider the category Graph having .-labeledgraphs as objects andgraph morphismsasarrows.Thesetof itsobjectswillbedenotedbyGr. The categorical structure inducesanobviouspreorderongraphs,defined asfollows. Definition 3 (Homomorphismpreorder). Givengraphs G and H, we write G . H if there is a graph morphism from G to H in Graph. The relation . is obviously a preorder (i.e. it is reflexive and transitive) and we call it the homomorphism preorder on graphs. We write G . H if G . H does not hold. Graphs G and H are homomorphically equivalent, written G . H, if both G . H and H . G hold. We will revisit the concept of retracts and cores from[15]. Cores are a convenientway tominimizetypegraphs,as,according to[15], allgraphs G, H with G . H have isomorphic cores. Definition 4 (Retract and core). A graph H is called a retract of a graph G if H is a subgraph of G and in addition there exists a morphism .: G . H. Agraph H is called a core of G, written H = core(G), if it is a retract of G and has itself no proper retracts. Example 5. The graph H is a retract of G, where the morphism . is indicated by the node numbering: G= 123456AABBB.. .1,52,43,6AB= HSince the graph H does not have a proper retract itself it is also the core of G. 3 Languages Specified by Type or Restriction Graphs Inthissectionwe introducetwoclassesofgraphlanguagesthatarecharacterized bytwo somewhatdualproperties.A typegraph language contains allgraphs that canbemappedhomomorphicallyto agiven typegraph, while a restriction graph language includes all graphs that do not contain an homomorphic image of a given restriction graph. Next, we discuss for these two classes of languages some properties such as closure under set operators, decidability of emptiness and inclusion, and decidability of closure under rewriting via double-pushout rules. Finallywediscussthe relationshipbetweenthesetwoclassesofgraph languages. Definition 6 (Type graph language). A type graph T is just a .-labeled graph. The language L(T )is defined as: L(T )= {G | G . T }. 3 Example 7. The following type graph T over the edge label set . = {A, B} specifies a type graph language L(T )consisting of infinitely many graphs: B A BAL() = . , A , , ,... A The category Graph has a final object, that we denote B T , consisting of one node (called flower node .) and = A.T. one loop for each label in .. Therefore L(T )= Gr..CThe graph T . for . = {A, B, C} is depicted to the right. . Specifyinggraphlanguagesusingtypegraphsgivesusthepossibilitytoforbid certaingraph structuresby not including them intothetypegraph.Forexample, nographinthe languageofExample7 cancontaina B-loop or an A-edge incident to the target of a B-edge.However,it isnotpossibletoforcesomestructuresto exist in all graphs of the language, since the morphism to the type graph need notbesurjective.Thispointwillbe addressed with the notionof annotated type graph in Section 5. Anotherway(possiblymoreexplicit) tospecify languagesofgraphsnot including certain structures, is the following one. Definition 8 (Restriction graph language). A restrictiongraph R isjust a .-labeled graph. The language LR(R)is defined as: LR(R)= {G | R . G}. We will consider the relationship between the class of languages introduced in Definitions 6 and 8 in Section 3.3. 3.1 Closure and Decidability Properties Thetypegraph and restrictiongraph languagesenjoy thefollowing complementary closureproperties with respectto set operators. Proposition 9. Typegraphlanguages areclosed underintersection(by taking the product of type graphs) but not under union or complementation, while restriction graph languages are closed under union (by taking the coproduct of restriction graphs) but not under intersection or complementation. Instead the two classes of languages enjoy similar decidability properties. Proposition 10. For a graph language L characterized by a type graph T (i.e. L = L(T ))or by a restriction graph R (i.e. L = LR(R))the following problems are decidable: 1. Membership, i.e. for each graph G it is decidable if G .L holds. 2. Emptiness, i.e. it is decidable if L = . holds. Furthermore, language inclusion is decidable for both classes of languages: 3. Given type graphs T1 and T2 it is decidable if L(T1).L(T2)holds. 4. Given restriction graphs R1 and R2 it is decidable if LR(R1) .LR(R2) holds. 4 3.2 Closure under Double-Pushout Rewriting In this subsection we are using the DPO approach with general, not necessarily injective,rulesand matches.Wediscusshowwecanshowthatagraph language L is a closed under a given graph transformation rule . =(L ..'L. I .'R. R), i.e., L is an invariant for .. This means that for all graphs G, H, where G can be rewritten to H via ., it holds that G .L implies H .L. Forbothtypegraphlanguagesandrestrictiongraphlanguages,separately, we characterize a sufficient and necessary condition which shows that closure under rule application is decidable. The condition for restriction graph languages is related toaconditionalready discussed in[13]. Proposition 11 (Closure under DPO rewriting for restriction graphs). A restriction graph language LR(S) is closed under a rule . =(L ..'L. I .'R. R) if and only if the following condition holds: for every pair of morphisms . : R . F , . : S . F which arejointly surjective, applying the rule . with(co)match. backwards to F yields a graph E with a homomorphic image of S, i.e., E 6. LR(S). Proposition 12 (Closure under DPO rewriting for typegraphs). A type graph language L(T )is closed under a rule . =(L ..'L. I .'R. R)if and only if for each morphism tL : L . core(T ), there exists a morphism tR : R . core(T ) such that tL . .L = tR . .R. . L(T )is closed under application of . . LIR.tL.L.R.tRcore(T ) We show that the only if part (.) of Proposition 12 cannot be weakened by considering morphisms to the type graph T , instead of to core(T ). In fact, consider the following type graph T and the rule .: A 12A1212BA. = T = B {A,B}The type graph T contains the flower node, i.e., it has T as subgraph. . This ensures thateachgraph G, edge-labeled over . = {A, B}, is in the language L(T ), and thus by rewriting any graph G .L(T ) into a graph H using . it is guaranteed that H .L(T ). However there is a morphism tL : L . T , the one mapping the A-labeled edge of L to the left A-labeled edge of T , such that there exists no morphism tR : R . T satisfying tL . .L = tR . .R. 5 3.3 Relating Type graph and Restriction Graph Languages Both type graph and restriction graph languages specify collections of graphs by forbidding the presence of certain structures. This is more explicit with the use of restriction graphs, though. A natural question is how the two classes of languagesarerelated.Apartial answertothis isprovidedbythenotionof duality pairs and by an important result concerning their existence, presented in [15].4 Definition 13 (Duality pair). Given two graphs R and T , we call T the dual of R if for every graph G it holds that G . T if and only if R . G. In this case the pair (R, T )is called duality pair. Clearly, we have that (R, T ) is a duality pair if and only if the restriction graph language LR(R)coincides with the type graph language L(T ). Example 14. Let . = {A, B} be given. The following is a duality pair: . . (R, T )= 1 A 2 B 3 , A 1 A, B 2 B Since node 1 of T is not the source of a B-labeled edge and node 2 is not the target of an A-labeled edge, for every graph G we have G . T iff it does not contain a node which is both the target of an A-labeled edge and the source of a B-labeled edge. But it contains such a node if and only if R . G. Onecan identifytheclassofrestrictiongraphsforwhich acorrespondingtype graphexistswhichdefinesthesamegraphlanguage.Resultsfrom[15]state5 that given a coregraphR, agraph T canbe constructed such that(R, T )is a duality pair if and only if R is a tree. Thus we have a precise characterisation of the intersection of the classes of type and restriction graph languages: L belongs to the intersection if and only if it is of the form L = LR(R)and core(R)is a tree. It is worth mentioning that the construction of T from R using the results from [15] contains two exponential blow-ups. This can be interpreted by saying that type graphs have limited expressiveness if used to forbid the presence of certain structures. 4 Type Graph Logic Inthissectionwe investigatethepossibility todefinea languageofgraphsusing a logicalformulaovertypegraphs.Westartbydefining thesyntaxand semantics of atypegraph logic(TGL). 4 Note that in [15] graphs are simple, but it can be easily seen that for our purposes the results can be transferred straightforwardly. 5 We refer to Lemma 2.3, Lemma 2.5 and Theorem 3.1 in [15]. 6 Definition 15 (Syntax and semantics of TGL). A TGL formula F over a fixed set of edge labels . is formed according to the following grammar: F := T | F . F | F . F |ÂF, where T is a type graph. Each TGL formula F denotes a graph language L(F ). Gr. defined by structural induction as follows: L(T )= {G . Gr. | G . T }L(ÂF )= Gr. \L(F ) L(F1 . F2)= L(F1).L(F2) L(F1 . F2)= L(F1).L(F2) Clearly, due to the presence of boolean connectives, boolean closure properties come for free. Example 16. Let the following TGL formula F over . = {A, B} be given: A BF = Â .Â Thegraph language L(F )consistsof allgraphs whichdo not consist exclusively of A-edges or of B-edges, i.e., which contain at least one A-labeled edge and at least one B-labeled edge, something that can not be expressed by pure type graphs. We now present some positive results for graph languages L(F ) over TGL formulas F with respect to decidability problems. Due to the conjunction and negationoperator,theemptiness(orunsatisfiability) check isnotastrivial as it is forpure typegraphs.Note that thanks to thepresence ofboolean connectives, inclusion can be reduced to emptiness. Proposition 17. For a graph language L(F ) characterized by a TGL formula F , the following problems are decidable: Ð Membership, i.e. for all graphs G it is decidable if G .L(F ) holds. Ð Emptiness, i.e. it is decidable if L(F )= . holds. Ð Language inclusion, i.e. given two TGL formulas F1 and F2 it is decidable if L(F1 ).L(F2)holds. Such a logic could alternatively also be defined based on restriction graphs. A related logic, for injective occurrences of restriction graphs, is studied in [17], wheretheauthorsalsogiveadecidability resultvia inferencerules. 5 Annotated Type Graphs Inthissectionwewill improvetheexpressivenessof thetypegraphsthemselves, rather than using an additional logic to do so. We will equip graphs with additional annotations. As explained in the introduction, this idea was already used similarly in abstract graph rewriting. In contrast to most other approaches, we will investigatetheproblemfromacategoricalpointof view. 7 The idea we follow is to annotate each element of a type graph with pairs of multiplicities, denoting upper and lower bounds. We will define a category of multiply annotated graphs, where we consider elements of a lattice-ordered monoid(short .-monoid) as multiplicities. Definition 18 (Lattice-ordered monoid). A lattice-ordered monoid (.monoid) (M, +, ²)consists of a set M, apartial order ² and a binary operation + such that Ð (M, ²)is a lattice. Ð (M, +) is a monoid; we denote its unit by 0. Ð It holds that a +(b . c)=(a +b). (a +c)and a +(b . c)=(a +b). (a +c), where ., . are the meet andjoin of ². We denote by .Mon the category having .-monoids as objects and as arrows monoid homomorphisms which are monotone. Example 19. Let n . N\{0} and take Mn = {0, 1, . . . , n, m} (zero, one,... , n, many) with 0 ² 1 ² ááá ² n ² m and addition as monoid operation with the proviso that .1 +.2 = m if the sum is larger than n. Clearly, for all a, b, c .Mn a . b = max{a, b} and a . b = min{a, b}. From this we can infer distributivity and therefore(Mn, +, ²)forms an .-monoid. Furthermore,given a setS and an .-monoid(M, +, ²), it iseasytocheckthat also({a: S . M}, +, ²)is an .-monoid, where the elements are functions from S to M and the partial order and the monoidal operation are taken pointwise. In the following we will sometimes denote an .-monoid by its underlying set. Definition20(Annotationsand multiplicitiesforgraphs). Given a functor A: Graph . .Mon, an annotationbased on A for a graph G is an element a .A(G). We write A', instead of A(.), for the action of functor A on agraph morphism .. We assume that for each graph G there is a standard annotation based on A that we denote by sG, thus sG .A(G). Given an .-monoid Mn = {0, 1, . . . , n, m} we define the functor Bn : Graph . .Mon as follows: Ð for every graph G, Bn(G)= {a:(VG . EG).Mn}; Ð for every graph morphism .: G . G . and a .Bn(G), we have B'n(a):VG. . EG. .Mn with: Bn(a)(y)= a(x), where x . (VG . EG)and y . (VG. . EG. ).'(x)=y Therefore an annotation based on a functor Bn associates every item of a graph with a number(or the top value m). We will call such kind of annotations multiplicities. Furthermore, the action of the functor on a morphism transforms a multiplicityby summing up(in Mn) the values of all items of the source graph that are mapped to the same item of the target graph. For agraph G,its standard multiplicity sG .Bn(G)isdefined as thefunction which maps every node and edge of G to 1. 8 Someof theresultsthatwewillpresent intherestof thepaperwillholdfor annotations based on a generic functor A, some only for annotations based on functors Bn, i.e. for multiplicities. The type graphs which we are going to consider are enriched with a set of pairs of annotations. The motivation for considering multiple annotations rather than a single one is mainly to ensure closure under union. Each pair can be interpreted as establishing a lower and an upper bound to what a graph morphism can map to the graph. Definition 21 (Multiplyannotatedgraphs). Given afunctorA: Graph . .Mon,a multiply annotated graph G[M](overA) is a graph G equipped with a finite set of pairs of annotations M .A(G).A(G), such that . ² u for all (., u). M. An arrow .: G[M] . G . [M . ], also called a legal morphism, is a graph . morphism .: G . G . such that for all (., u) . M there exists (. . ,u . ) . M . with A'(.) ³ . . and A'(u) ² u . We will write G[., u] as an abbreviation of G[{(., u)}]. In case of annotations based on Bn, we will often call a pair (., u)a double multiplicity. Multiply annotated graphs and legal morphisms form a category. Lemma 22. The composition of two legal morphisms is a legal morphism. Example 23. Consider the following multiply annotatedgraphs(over B2)G[., u] and H[. . ,u . ], both having one double multiplicity. A [0,1] A [0,m] G[., u]= H[. . ,u . ]= [1,1] [1,m] [1,m] As evident from the picture, multiplicities are represented by writing the lower and upper bounds next to the corresponding graph elements. Note that there isaunique,obviousgraph morphism .: G . H, mappingboth nodes of G to the only node of H. Concerning multiplicities, by adding the lower and upper bounds of the two nodes of G,onegetsthe interval[2,m]whichis included in the interval of the node of H, [1,m]. Similarly, the double multiplicity [0, 1] of the . edge of G is included in [0,m]. Therefore, since both B2 (.)³ . . and B2 (u)² u''hold, we can conclude that .: G[., u]. H[. . ,u . ]is a legal morphism. We are now ready to define how a graph language L(T [M]) looks like. Definition 24 (Graph languages of multiply annotated type graphs). We say that a graph G is represented by a multiply annotated type graph T [M] whenever there exists a legal morphism .: G[sG,sG]. T [M], i.e., there exists (., u). M such that . ²A'(sG)² u. We will write G .L(T [M]) in this case. Whenever M = . for a multiply annotated type graph T [M]we get L(T [M]) = .. An extended example can be found in Appendix B. 9 5.1 Decidability Properties for Multiply Annotated Graphs We now address some decidability problems for languages defined by multiply annotated graphs. We get positive results with respect to the membership and emptinessproblems.However,fordecidability of language inclusionweonlyget partial results. Forthe membershipproblem we can simply enumerate allgraph morphisms .: G . T and check if there exists a legal morphism .: G[sG,sG]. T [M]. The emptiness check is somewhat more involved, since we have to take care of ÒillegalÓ annotations. Proposition 25. For agraph language L(T [M]) characterized by a multiply annotated typegraph T [M]over Bn the emptinessproblemisdecidable: L(T [M]) = . iff M = . orfor each (., u). M there exists an edge e . ET such that .(e)³ 1 and (u(src(e))=0 or u(tgt(e))=0). Language inclusion can be deduced from the existence of a legal morphism between the two multiply annotated type graphs. Proposition 26. The existence of a legal morphism .: T1[M]. T2[N]implies L(T1[M]) .L(T2[N]). We would like to remark that this condition is sufficient but not necessary, and we present the following counterexample. Let the following two multiply annotatedtypegraphs T1[M1]and T2[M2]over B1 begiven where|M1| = |M2| = 1: T1[M1]= T2[M2]= [1,m] [1, 1] [0,m] Clearly we have that the languages L(T1[M1]) and L(T2[M2]) are equal as both contain all discrete non-empty graphs. Thus L(T1[M1]) .L(T2[M2]), but there exists no legal morphism .: T1[M1]. T2[M2]. In fact, the upper bound of the first node of T2 would be violated if the node of T1 is mapped by . to it, while the lower bound would be violated if the node of T1 is mapped to the other node. 5.2 Deciding Language Inclusion for Annotated Type Graphs Inthissectionweshowthat ifweallowonlyboundedgraphlanguagesconsisting of graphs up to a fixed pathwidth, the language inclusion problem becomes decidable for annotations based on Bn. Pathwidth is a well-known concept from graph theory that intuitively measures how much a graph resembles a path. The proof is based on the notion of recognizability, which will be described via automaton functors that were introduced in [4]. We start with the main result and explain step by step the arguments that will lead to decidability. 10 Proposition 27. The language inclusion problem is decidable for graph languagesofboundedpathwidth characterizedby multiply annotated typegraphs over Bn . That is, given k . N and two multiply annotated type graphs T1[M1] and T2[M2] over Bn, it is decidable whether L(T1[M1])²k .L(T2[M2])²k, where L(T [M])²k = {G .L(T [M]) | G has pathwidth ² k}. Our automaton model, given by automaton functors, reads cospans (i.e., graphs with interfaces) instead of single graphs. Therefore in the following, the category under consideration will be Cospan(Graph), i.e. the category mof cospans of graphs where the objects are discrete graphs J, K and the arrows are cospans c: J . G . K where both graph morphisms are injective. We will refer to the graph J as the inner interface and to the graph K as the outer interface of the graph G. In addition we will sometimes abbreviate the cospan c: J . G . K to the short representation c: JK. According to [3] a graph has pathwidth k iff it can be decomposed into cospans where each middle graph of a cospan has at most k +1 nodes. Hence it is easy to check that a path has pathwidth 1, while a clique of order k has pathwidth k . 1. Ourmaingoalistobuildanautomatonwhich canread allgraphsof our languagestepbystep,similartothe ideaof finiteautomatareading words informal languages. Such an automaton can be constructed for an unbounded language, where the pathwidth is not restricted. However, we obtain a finite automaton only if we restrict the pathwidth. Then we can use well-known algorithms for finite automata to solve the language inclusion problem. Note that, if we would use tree automata instead of finite automata, our result could be generalized to graphs of bounded treewidth. Wewill first introducethenotionof automatonfunctor(which isacategorical automaton model for so-called recognizable arrow languages) and which is inspiredby CourcelleÕstheory of recognizablegraph languages[8]. Definition 28 (Automaton functor [4]). An automaton functor C : Cospan(Graph) . Rel is a functor that maps every object J (i.e., evmery discrete graph) to a finite set C(J)(the set of states of J)and every cospan c: JK to a relation C(c) .C(J).C(K) (the transition relation of c). In addition there is a distinguished set of initial states I .C(.)and a distinguished set of final states F .C(.). The language LC of C is defined as follows: A graph G is contained in LC if and only if there exist states q . I and . q . F which are relatedby C(c),i.e. (q, q . ).C(c), where c: . . G . . is the unique cospan with empty interfaces and middle graph G. Languages accepted by automaton functors are called recognizable. We will now define an automaton functor for a type graph T [M]over Bn . Definition 29 (Countingcospan automaton). LetT [M]be a multiply annotated typegraph over Bn.Wedefine an automatonfunctor CT [M] : Cospan(Graph)m. Rel as follows: 11 Ð For each object J of Cospan(Graph) (thus J is a finite discrete graph), mCT [M](J)= {(f, b)| f : J . T,b .Bn(T )} is its finite set of states Ð I .CT [M](.) is the set of initial states with I = {(f : . . T, 0)}, where 0 is the constant 0-function Ð F .CT [M](.) is the set of final states with F = {(f : . . T,b)|.(., u). M : . ² b ² u} Ð Let c: J . L. G .. R. K be an arrow in the category Cospanm(Graph) with discrete inter-c: J # K face graphs J and K where both graph morphisms .L .R.L : J . G and .R : K . G are injective. Two G K. states (f : J . T,b)and (f : K . T,b . )are in the J .h .relation CT [M](c) if and only if there exists a mor-f f phism h: G . T such that the diagram to the right commutes and for all x . VT . ET the following T equation holds: b . (x)= b(x)+|{y . (G \ .R(K))| h(y)= x}| The set G \ .R(K) consists of all elements of G which are not targeted by the morphism .R, e.g. G \ .R(K) =(VG \ .R(VK )). (EG \ .R(EK )). Instead of LCT [M] and CT [M] wejust write LC and C if T [M]is clear from the context. The intuition behind this construction is to count for each item x of T , step by step, the number of elements that are being mapped from a graph G (which is in the form of a cospan decomposition) to x, and then check if the bounds of apair of annotations(., u). M of the multiply annotated typegraph T [M]are satisfied. We give a short example before moving on to the results. Example 30. Letthefollowing multiply annotatedtypegraph(over B2)T [., u] and the cospan(c: . . G . .)with G .L(T [., u]) be given: A [0,2] B [0,m] c:T [., u]= [0,1] [1,m] ?AB?We will now decompose the cospan c into two cospans c1,c2 with c = c1;c2 in the following way: c1 c2 ?AB?c We letourcounting cospanautomatonparsethecospandecomposition c1;c2 step by step now to show how the annotations for the type graph T evolve during the process. According to our construction, every element in T has multiplicity 0 in the initial state of the automaton. We then sum up the number of elements within the middlegraphs of the cospans which are not partof the right interface. Therefore we get the following parsing process: 12 ?AB?[0][0]A[0]B[0][1][0]A[1]B[0][1][2]A[1]B[1]f1f2f3?AB?[0][0]A[0]B[0][1][0]A[1]B[0][1][2]A[1]B[1]f1f2f3q1 q2 q3 We visited three states q1,q2 and q3 inthe automaton with(q1,q2).C(c1)and (q2,q3).C(c2).SinceC is supposedtobe afunctor wegetthat C(c1);C(c2)= C(c) and therefore(q1,q3).C(c)alsoholds.In additionwehave q1 . I and since the annotation function b .B2(T ) in q3 =(f3,b) satisfies . ² b ² u we can infer that q3 . F . Therefore we can conclude that G .LC holds as well. We still need to prove that C is indeed a functor. Intuitively this shows that acceptance of a graph by the automaton is not dependent on its specific decomposition. Proposition 31. Let c1 : J . G . K and c2 : K . H . L be two arrows and let idG : G . G . G be the identity cospan. The mapping CT [M] : Cospan(Graph). Rel is a functor: m1. CT [M](idG)= idCT [M] (G) 2. CT [M](c1;c2)= CT [M](c1);CT [M](c2) The language accepted by the automaton LC is exactly the graph language L(T [M]). Proposition 32. Let the multiply annotated type graph T [M] (over Bn) and the corresponding automaton functor C : Cospan(Graph). Rel for T [M] be mgiven. Then LC = L(T [M]) holds,i.e.for agraph G we have G .L(T [M]) if and only if there exist states i . I .C(.)and f . F .C(.)such that (i, f).C(c), where c: . . G . .. Therefore we can construct an automaton for each graph language specified by a multiply annotated type graph T [M], which accepts exactly the same language.Incaseofaboundedgraphlanguagethisautomatonwillhaveonly finitely many states.Furthermorewecanrestrictthe label alphabet, i.e.,thecospansby using only atomic cospans, adding a single node or edges(see [2]).Once these steps are performed, we obtain conventional non-deterministic finite automata overa finitealphabet and wecanusestandard techniquesfromautomatatheory to solve the language inclusion problem directly on the finite automata. 5.3 Closure Properties for Multiply Annotated Graphs Extending the expressiveness of the type graphs by adding multiplicities gives us positive results in case of closure under union and intersection. Here we use constructions that rely on products and coproducts in the category of graphs. 13 Closureunder intersectionholdsforthemostgeneralformof annotations.From T1[M1], T2[M2]we can construct an annotatedtypegraph(T1 . T2)[N], where N contains all annotations which make both projections ¹i : T1 . T2 . Ti legal. Proposition 33. The category of multiply annotated graphs is closed under intersection. We canprove closure under unionfor the case ofannotationsbased onthefunctor Bn.Here wetakethe coproduct(T1 . T2)[N], where N contains all annotations of M1, M2, transferred to T1 . T2 via the injections ij : Tj . T1 . T2. Intuitively, graph items not in the original domain of the annotations receive annotation [0, 0]. This can be generalized under some mild assumptions(see proof in the appendix). Proposition 34. The category of multiply annotated graphs over functor Bn is closed under union. Closure under complement is still an open issue. If we restrict to graphs of boundedpathwidth, wehave a(non-deterministic) automaton(functor), asdescribedinSection5.1,which couldbedeterminized and complemented.However, this does not provide us with an annotated type graph for the complement. We conjecture that closure under complement does not hold. 6 Conclusion Ourresultsondecidability and closurepropertiesforspecification languagesare summarized in the following table. In the case where the results hold only for bounded pathwidth, the checkmark is in brackets. Pure TG Restr. Gr. TG Logic Annotated TG Decidability G . L? L = .? L1 . L2? . . . . . . . . . . . (.) Closure Properties L1 . L2 L1 . L2 Gr. \ L . . . . . . . . . . . ? Oneopenquestionthatremains iswhether language inclusionforannotated type graphs is decidable if we do not restrict to bounded treewidth. Similarly, closure under complement is still open. Furthermore, in order to be able to use these formalisms extensively in applications, it isnecessarytoprovideamechanismtocomputeweakestpreconditions and strongest postconditions. This does not seem feasible for pure type graphs orthetypegraph logic.Hence, wearecurrentlyworking oncharacterizing weakest preconditions and strongest postconditions in the setting of annotated type graphs. This requires a materialisation construction, similar to [23], which we 14 plan to characterize abstractly, exploiting universal properties in category theory. Notethatourannotationsareglobal, i.e.,wecount all items that are mapped to a specific item in the type graph. This holds also for edges, as opposed to UML multiplicities,which are local wrt.theclasseswhich arerelatedby anedge (i.e., an association). We plan to studythe possibility to integrate this into our frameworkand investigatethecorrespondingdecidability and closureproperties. Related work: As already mentioned there are many approaches for specifying graph languages.Onecannotsay thatone issuperiortotheother,usuallythere is atradeoffbetween expressiveness anddecidabilityproperties,furthermorethey differ in terms of closure properties. Recognizable graph languages [7,8], which are the counterpart to regular wordlanguages,arecloselyrelated with monadicsecond-ordergraphlogic.If one restrictsrecognizablegraphlanguagestobounded treewidth(orpathwidth aswe did), one obtains satisfactorydecidabilityproperties.On the otherhand, the size oftheresultinggraph automata isoftenquite intimidating[2] andhencethey aredifficulttowork with inpractical applications.Theuseof nested application conditions [12], equivalent to first-order logic [20], has a long tradition in graph rewriting and they canbe used to computepre-andpostconditionsfor rules [18]. However, satisfiability and implication are undecidable for first-order logic. Anotionofgrammarsthat isequivalenttocontext-free(word)grammarsare hyperedge replacement grammars [11]. Many aspects of the theory of context-free languages can be transferred to the graph setting. In heap analysis the representation of pointer structures to be analyzed requires methods to specify sets of graphs. Hence both the TVLA approach by Sagiv, Reps and Wilhelm [23], as well as separation logic [16,9] face this problem. In [23] heaps are represented by graphs, annotated with predicates from a three-valued logics(withtruth values yes, no and maybe). A further interesting approach are forest automata [1] that have many interesting properties, but are somewhat complex to handle. In [22] the authors study an approach called Diagram Predicate Framework (DPF), in which type graphs have annotations based on generalized sketches. ThisformalismisintendedforMOF-based modelling languagesand allowsmore complex annotations than our framework. References 1. Parosh Aziz Abdulla, Luk«as Hol«õk, Bengt Jonsson, Ondrej Leng«al, Cong Quy Trinh, and Tom«as Vojnar. Verification of heap manipulating programs with ordered data by extended forest automata. In Proc. of ATVA Õ13, pages 224Ð239, 2013. LNCS 8172. 2. Christoph Blume, H.J. Sander Bruggink, Dominik Engelke, and Barbara K¬onig. Efficient symbolic implementation of graph automata with applications to invariant checking. In Proc. of ICGT Õ12, pages 264Ð278. Springer, 2012. LNCS 7562. 3. Christoph Blume, H.J. Sander Bruggink, Martin Friedrich, and Barbara K¬onig. Treewidth, pathwidth and cospan decompositions with applications to graph15 accepting tree automata. Journal of Visual Languages & Computing, 24(3):192Ð 206, 2013. 4. H.J. Sander Bruggink and Barbara K¬onig. On the recognizability of arrow and graph languages. In Proc. of ICGT Õ08, pages 336Ð350. Springer, 2008. LNCS 5214. 5. Edmund M. Clarke, Orna Grumberg, Somesh Jha, Yuan Lu, and Helmut Veith. Counterexample-guided abstraction refinement for symbolic model checking. Journal of the ACM, 50(5):752Ð794, 2003. 6. Andrea Corradini, Ugo Montanari, and Francesca Rossi. Graph processes. Fundamenta Informaticae, 26(3/4):241Ð265, 1996. 7. Bruno Courcelle. The monadic second-order logic of graphs I. Recognizable sets of finite graphs. Information and Computation, 85:12Ð75, 1990. 8. Bruno Courcelle and Joost Engelfriet. Graph Structure and Monadic Second-Order Logic, A Language-Theoretic Approach. Cambridge University Press, June 2012. 9. Dino Distefano, Peter W. OÕHearn, and Hongseok Yang. A local shape analysis based on separation logic. In Proc. of TACAS Õ06, pages 287Ð302. Springer, 2006. LNCS 3920. 10. J¬org Endrullis and Hans Zantema. Proving non-termination by finite automata. In RTA Õ15, volume 36 of LIPIcs, pages 160Ð176. Schloss DagstuhlÐLeibniz-Zentrum fuer Informatik, 2015. 11. Annegret Habel. Hyperedge Replacement: Grammars and Languages. Springer-Verlag, 1992. LNCS 643. 12. Annegret Habel and Karl-Heinz Pennemann. Nested constraints and application conditions for high-level structures. In Formal Methods in Software and Systems Modeling. Essays Dedicated to Hartmut Ehrig, on the Occasion of His 60th Birthday, pages 294Ð308. Springer, 2005. LNCS 3393. 13. Reiko Heckel and Annika Wagner. Ensuring consistency of conditional graph rewriting Ð a constructive approach. In Proc. of the Joint COMPUGRAPH/SEMAGRAPH Workshop on Graph Rewriting and Computation, volume 2 of ENTCS, 1995. 14. Stephen Lack and Pawe l Soboci«nski. Adhesive and quasiadhesive categories. RAIRO Ð Theoretical Informatics and Applications, 39(3), 2005. 15. Jaroslav Neÿsetÿril and Claude Tardif. Duality theorems for finite structures (characterising gaps and good characterisations). Journal of Combinatorial Theory, Series B, 80:80Ð97, 2000. 16. Peter W. OÕHearn. Resources, concurrency and local reasoning. Theoretical Computer Science, 375(1Ð3):271Ð307, May 2007. Reynolds Festschrift. 17. Fernando Orejas, Hartmut Ehrig, and Ulrike Prange. A logic of graph constraints. In Proc. of FASE Õ08, pages 179Ð198. Springer, 2008. LNCS 4961. 18. Karl-Heinz Pennemann. Development of Correct Graph Transformation Systems. PhD thesis, Universit¬at Oldenburg, May 2009. 19. Arend Rensink. Canonical graph shapes. In Proc. of ESOP Õ04, pages 401Ð415. Springer, 2004. LNCS 2986. 20. Arend Rensink. Representing first-order logic using graphs. In Proc. of ICGT Õ04, pages 319Ð335. Springer, 2004. LNCS 3256. 21. Grzegorz Rozenberg, editor. Handbook of Graph Grammars and Computing by Graph Transformation, Vol.1: Foundations. World Scientific, 1997. 22. Adrian Rutle, Alessandro Rossini, Yngve Lamo, and Uwe Wolter. A diagrammatic formalisation of MOF-based modelling languages. In Proc. of TOOLS EUROPE Õ09, pages 37Ð56. Springer, 2009. LNBIP 33. 16 23. Mooly Sagiv, Thomas Reps, and Reinhard Wilhelm. Parametric shape analysis via 3-valued logic. TOPLAS (ACM Transactions on Programming Languages and Systems), 24(3):217Ð298, 2002. 24. Dominik Steenken, Heike Wehrheim, and Daniel Wonisch. Sound and complete abstract graph transformation. In Proc. of SBMF Õ11, pages 92Ð107. Springer, 2011. LNCS 7021. 17 A Proofs A.1 Languages Specified by Type or Restriction Graphs Proposition 9. Type graph languages are closed under intersection (by taking the product of type graphs) but not under union or complementation, while restriction graph languages are closed under union (by taking the coproduct of restriction graphs) but not under intersection or complementation. Proof. The product T1 . T2 has the property that for any graph G we have G . T1 . T2 if and only if G . T1 and G . T2. Hence, given two type graphs T1 and T2, by the universal property of the product graph we get immediately the following equality: L(T1).L(T2)= L(T1 . T2). Dually, given two restriction graphs R1 and R2, we show that LR(R1). LR(R2)= LR(R1 . R2). In fact,G 6. LR(R1 . R2)iff R1 . R2 . G, iff(by the universal property of coproducts) R1 . G and R2 . G, iff G 6. LR(R1) and G 6. LR(R2), iffG 6. (LR(R1).LR(R2)). For the negative results, we will show counterexamples using the following graphs over . = {A, B}: BGA = A GB = We first show by contradiction that there is no type graph T such that L(T )= L(GA).L(GB ). In fact, the type graph language L(GA) contains all graphs which do not have any B-labeled edge, and L(GB ) contains all graphs which do not have any A-labeled edge. Since GA,GB .L(GA).L(GB ), we would have GA . T and GB . T , which implies that T contains at least one A-labeledloop(thus T . GB )and one B-labeledloop(thus T . GA).Itfollows that T 6. L(GA).L(GB ), but insteadT .L(T )yielding a contradiction. Nowweshowby contradictionthatthere isnorestrictiongraph R such that LR(R)= LR(GA).LR(GB ).Infact, ifsuchan R exists we wouldhave LR(R). LR(GA), and thus R . GA by Proposition 10.4, and LR(R) .LR(GB ), and thus R . GB. But R . GA means that R has no B-edges, and R . GB that it has noA-edges, thus R mustbediscrete.Thisyields a contradiction,because any graph G with no loops but with at least one edge belongs to LR(GA).LR(GB) but not to LR(R), becauseR . G. The lack of closure under complementation immediately follows from these negative results and the fact that union can be expressed using intersection and complementation, and dually. .. Proposition 10. For a graph language L characterized by a type graph T (i.e. L = L(T ))or by a restriction graph R (i.e. L = LR(R))the following problems are decidable: 1. Membership, i.e. for each graph G it is decidable if G .L holds. 2. Emptiness, i.e. it is decidable if L = . holds. Furthermore, language inclusion is decidable for both classes of languages: 18 3. Given type graphs T1 and T2 it is decidable if L(T1).L(T2)holds. 4. Given restriction graphs R1 and R2 it is decidable if LR(R1) .LR(R2) holds. Proof. 1. Todecidewhether G .L(T )(orG .LR(R))holds, we needto check for the existence of a morphism .: G . T (or for the non-existence of a morphism .: R . G),which isobviouslypossiblebecausegraphsare finite. Nevertheless,notethatthisproblem isNP-complete.For instance,searching for a morphism from any graph into the 3-clique is the same as deciding if the graph is 3-colorable. 2. The emptiness problem is pretty trivial. If L = L(T ) for a type graph T , then L(T )6. because it holds . .L(T )(recall that. is the initial object = of Graph). If instead L = LR(R) for a restriction graph R, then L = . if and only if R = .. In fact, if R = . then R . G for all G . Graph, and thus LR(R)= .. Instead if R 6. then clearly R 9., thus . .LR(R)= .. 3. We show that L(T1).L(T2)iff T1 . T2, which is decidable. .: Assume L(T1).L(T2) holds. Since T1 .L(T1) holds then T1 .L(T2) also holds and therefore T1 . T2. .: Assume T1 . T2 holds, and let G .L(T1). ThereforeG . T1, and by transitivity G . T2, thus G .L(T2). 4. We show that LR(R1).LR(R2)iff R1 . R2. .: Assume that LR(R1) .LR(R2) holds. Equivalently, {G | R2 . G} = LR(R2).LR(R1)= {G | R1 . G}, where we wrote L for the complement language(Gr. \L). Thus, since obviouslyR2 . R2, we obtain R1 . R2. .:Assumethat R1 . R2 holds andthatG .LR(R1), whichmeans R1 . G. If, by contradiction, G 6. LR(R2),then wehaveR2 . G and,by transitivity, R1 . G, which is a contradiction. .. Proposition 11. A restriction graph language LR(S) is closed under a rule . =(L ..'L. I .'R. R) if and only if the following condition holds: for every pair of morphisms . : R . F , . : S . F which arejointly surjective, applying the rule . with(co-)match . backwards to F yields agraphE with ahomomorphic image of S, i.e., E 6. LR(S). Proof. .: Assume that the condition holds. Now let G, H with G .. H. Insteadof showingthat G .LR(S)impliesH .LR(S), we showthatH 6. LR(S) implies G 6. LR(S). Since G .. H wehavethefollowingDPOdiagram(below,onthe left) for a rule . =(L ..'L. I .'R. R).R. Furthermore, since H 6. LR(S), there exists 19 a morphism S . H. 'L 'R 'L 'R SL Ioo //  R S.......GCoo // HL Ioo //  R ........ww E  C.   oo // F  GCoo // HNowtakethejoint image F of R and S in H, i.e.,factorthemorphisms ., . into R . F . H and S . F . H, where the arrows R . F , S . F arejointly epi. Since we are working in an adhesive category, the pushouts split into pushouts according to [14] (see diagram above, on the right). Now, E is obtained from F by applying rule . backwards. Hence, the condition implies that there exists a morphism S . E and this means that there is a morphism S . G, which implies G 6. LR(S). .: Assume that LR(S)is closed under rewriting via a rule .. We show that the condition holds. Let . : R . F , . : S . F be a pair of morphisms which are jointly epiand assume that E is obtained from F by applying . backwards. Now, since E .. F and H 6. LR(S), we infer thatG 6. LR(S), otherwise we would have a counterexample to closure under rewriting. Hence there exists a morphism S . E. .. For the next result we need to recall the following lemma presented in [15]. Lemma 35 (Lemma 2.1 of [15]). Let T be a graph and core(T ) be its core. . Then for each morphism f : T . core(T )there exists a morphism f : core(T ). .. T such that f . f = idcore(T ). Vice versa, for each morphism g : core(T ). T . there exists a morphism g : T . core(T )such that g . g = idcore(T ). Proposition 12. A type graph language L(T ) is closed under a rule . = (L ..'L. I .'R. R) if and only if for each morphism tL : L . core(T ), there exists a morphism tR : R . core(T )such that tL . .L = tR . .R. . .L .R L I R L(T )is closed under application of . . .tL.tRcore(T ) Proof. .: Notice that if L 6. L(T )then there is no morphism tL : L . core(T )and wearedone.Otherwise, let tL : L . core(T ), and letn : I . core(T )be defined as n = tL . .L. Consider the following diagram, where the top span is the rule, 20 and the two squares arebuilt aspushouts(A is the pushout of .L,n; B is the pushout of .R,n). 'L 'R LIR  tL.. A.......oo nm f core(T ) B .....id .. .. . .g."".  ..||core(T ) Arrow A . core(T ) is uniquely determined because the left square is a pushout and id . n = tL . .L. This arrow witnesses that A .L(T ) (because core(T ). T ), and thus byassumption B .L(T ), because obviouslyA .. B. Therefore weknow that B . T , andthus that there is an arrow g : B . core(T ). Ingeneral,thisarrowdoesnot makethe lowerrighttrianglecommute,butgiven that we also have arrow f : core(T ) . B as the base of the right pushout, it .follows that B . T and hence core(B)= core(T ). Therefore by Lemma 35, .. we know that there is an arrow g : B . core(T ) such that g . f = idcore(T ) . (in particular, g =(g . f).1 . g). Therefore in the above diagram also the . lower right triangle commutes, and arrow tR = g . m : R . core(T ) satisfies tL . .L = tR . .R, as desired. .: Assume that G .L(T )by morphism tG : G . T , and that G is rewritten to H via rule . =(L ..'L. I .'R. R).R. Also, let t be any arrow from T to core(T ). This gives us the diagram below, where the two squares are pushouts, and the left triangle commutes by taking for C . core(T ) the composition t . tG . .L. .L .R LIRGCHcore(T) mnm. .L.Rt.tGtRtHBy assumption, since t . tG . m: L . core(T ), there exists a morphismtR : R . core(T )such that t.tG .m..L = tR ..R.This means that the square consisting ofI, C, R, core(T )commutes,that is t.tG..L.n = t.tG.m..L = tR..R.Hence there exists a mediating morphism tH : H . core(T ), which impliesH .L(T ) because core(T ). T . ..A.2 Type Graph Logic Proposition 17. For a graph language L(F ) characterized by a TGL formula F , the following problems are decidable: 21 Ð Membership, i.e. for all graphs G it is decidable if G .L(F ) holds. Ð Emptiness, i.e. it is decidable if L(F )= . holds. Ð Language inclusion, i.e. given two TGL formulas F1 and F2 it is decidable if L(F1 ).L(F2)holds. Proof. Membership: The membership problem for graph languages over TGL formulae isdecidablesince it isdecidableforevery typegraph language L(T ). We simply build the syntax tree of the formula F and search for morphisms .i : G . Ti at the leafs of the tree. Afterwards we pass the boolean results up to the root to decide whether G .L(F )holds. Emptiness: In order to show whether L(F )= . holds, we transform F into disjunctivenormalform(DNF).It issufficienttocheck whetherallconjunctions of theform(T0 .ÂT1 .á á á.ÂTn)areunsatisfiable.Wecanassumethatthere isat most one positive type graph in every conjunction, since type graphs are closed under conjunction/intersection. Furthermore we can even assume that there is exactly one positive type graph, since we always add T. (the flower graph). Now we have: L(T0 .ÂT1 . ... .ÂTn)= . .. L(T0 .Â(T1 . ... . Tn))= . .. L(T0).L(T1 . ... . Tn)= . .. L(T0).L(T1 . ... . Tn) .. L(T0).L(T1). ... .L(Tn) .. ..: T0 . Tk for some index 1 ² k ² n Therefore, we need to check whetherfor each of the conjunctions(T0 .ÂT1 .ááá. ÂTn)in the DNF of F , there exists a morphism .: T0 . Tk for some 1 ² k ² n . Inclusion: The language inclusionproblemcanbereducedtotheaforementioned emptiness problem. To solve the language inclusion we use the following equivalence: L(F1).L(F2) .. L(F1 .ÂF2)= . Since the emptiness problem is decidable we can conclude that the language inclusion problem is decidable as well. .. A.3 Annotated Type Graphs Lemma 22. The composition of two legal morphisms is a legal morphism. Proof. Let .1 : T1[M1] . T2[M2] and .2 : T2[M2] . T3[M3] be two legal morphisms in the category of multiply annotated graphs. Since .1 is legal we get that for all (.1,u1) . M1 there exists (.2,u2) . M2 such that .2 ²A'1 (.1) and A'1 (u1)² u2 hold. Furthermore .2 is legal and thereforewegetthatforall (.2,u2). M2 there exists(.3,u3). M3 suchthat .3 ²A'2 (.2)and A'2 (u2)² u3 hold as well. We define .: T1[M1]. T3[M3]to be the composed morphism with . = .2 ..1 anddue to thefact that A is afunctor whichpreserves monotonicity, we get the following two inequalities: 22 .2 ²A'1 (.1) .A'2 (.2)²A'2 (A'1 (.1)) . .3 ²A'2 (.2)²A'2 .'1 (.1) . .3 ²A'(.1) A'1 (u1)² u2 .A'2 (A'1 (u1))²A'2 (u2) .A'2 .'1(u1)²A'2 (u2)² u3 .A'(u1)² u3 Since both .3 ²A'(.1)and A'(u1)² u3 hold, the morphism . is legal. ..Proposition 25. For a graph language L(T [M]) characterized by a multiply annotated type graph T [M] over Bn the emptiness problem is decidable: L(T [M]) = . iff M = . or for each (., u) . M there exists an edge e . ET such that .(e)³ 1 and (u(src(e))=0 or u(tgt(e))=0). Proof. .:Assume that M = ., in this case L(T [M]) isclearlyempty aswell.Assumethatthere isanannotation(., u). M suchthat .(e)³ 1and(u(src(e))=0 or u(tgt(e))= 0) for some edge e . ET . Then no graph can satisfy these lower and upperbounds,sinceweareforced tomap at least oneedgeto e, but are not allowed to map any node to the source respectively target node. If this is true for all annotations, the language of the type graph must be empty. .: Now assume that M 6. and there exists one annotation(., u)= . M such that for every edge e . ET with .(e)³ 1 we have u(src(e))³ 1 and u(tgt(e))³ 1). Now take T [., u] and remove from T all edges and nodes x with u(x) =0, resulting in a graph T . . If a node is removed all incident edges are removed as well. Note that in such a case only edges e with .(e)=0willberemoved(due to the condition above). . .Now define . . = .|T . and u = u|T . Due to the considerations above there exists a legal morphisms (embedding) T . [. . ,u . ] # T [., u], since the removed items had a lower bound of 0. Furthermore each remaining item has an upper bound of at least 1, i.e., it represents at least one node or edge. . Now construct a graph G from T by proceeding as follows: for every node v with . . (v)= k add k . 1 isolated nodes (zero isolated nodes if k = 0). For every edge e with . . (e)= k put k parallel edges between src(e), tgt(e). There is . a morphism .: G . T obtained by mapping everyitem to the item from which it orginated. . Mapping G[sG,sG] to T via . will give us an annotation Bn(sG). This an'notation will coincide will the lower bound . in all cases, apart from the case where there is a node v with .(v) = 1. In this case Bn(sG)(v) = 1, but this is 'covered by the upper bound which is at least 1. Hence there is a legal graph morphism from G[sG,sG]to T . [. . ,u . ]and Ð by composition Ð to T [., u]. Hence G .L(T [M]) and hence L(T [M]) 6.. .= .Proposition 26. The existence of a legal morphism .: T1[M]. T2[N]implies L(T1[M]) .L(T2[N]). Proof. Everygraph G .L(T1[M]) has a legal morphism . . : G[sG,sG]. T1[M]. Whenever there exists a legal morphism .: T1[M] . T2[N] between the two 23 multiply annotated typegraphs, we obtainthe morphism . : G[sG,sG]. T2[N] with . = . . . . which is legal due to Lemma 22. Therefore G . T2[N]holds and we can conclude that L(T1[M]) .L(T2[N]) also holds. .. Proposition 31. Let c1 : J . G . K and c2 : K . H . L be two arrows and let idG : G . G . G be the identity cospan. The mapping CT [M] : Cospan(Graph). Rel is a functor: m1. CT [M](idG)= idCT [M] (G) 2. CT [M](c1;c2)= CT [M](c1);CT [M](c2) Proof. 1. The identity relation idCT [M] (G) consists of all pairs (i, i) with i . CT [M](G). Let the two statesi, j .CT [M](G)be given with i =(f1 : G . T,b1) and j =(f2 : G . T,b2). Thepair(i, j)is in the relation CT [M](idG)if and only if there exists a morphism h: G . T such that, for all6 x . T the equation b2(x)= b1(x)+ |{y . (G \ id(G))| h(y)= x}| holds and the following diagram commutes: idG : GG id id G G G f1.hf2T Since thediagram commutes we obtain that f1 = f2 since f1 = id;h = h;id = f2 holds and for all x . T the annotation functions b1 and b2 are equal due to the following equation: b2(x)= b1(x)+|{y . (G \ id(G))| h(y)= x}| = b1(x)+|{y . . | h(y)= x}| = b1(x)+0= b1(x) This is equivalent to i = j and therefore for all i . CT [M](G) the following equation holds: CT [M](idG)= {(i, j). CT [M](G). CT [M](G)| i = j} = idCT [M] (G) Therefore CT [M](idG)= idCT [M] (G) holds. Inthefollowingpart let c1 : J .g1 . G ..g2 . K and c2 : K .g1 . . H ..g2 . . L begiven .and let c = c1;c2 with c: J .g1 ;j1 . G . ..g ;j2 . L be the composed morphism of 2 c1 and c2. 2. .: Let(i, j).CT [M](c1;c2)begiven with i .CT [M](J)and j .CT [M](L)such that i =(f1 : J . T,b1)and j =(f3 : L . T,b3). Then there exists a morphism . h: G . . T such that b3(x)= b1(x)+|{y . (G . \ g2;j2(L))| h(y)= x}| holds for all x . T and the following diagram commutes: 6 We write x . T as an abbreviation for x . VT . ET . 24 c1 : JK c2 : KL .. ggg1 g212 J G K H L G.f1j1j2.hf3T Toprove that(i, j).CT [M](c1);CT [M](c2)issatisfiedfromtheaboveproperties, we need to show that there exists a k .CT [M](K) where k =(f2 : K . T,b2) . such that(i, k).CT [M](c1)and(k, j).CT [M](c2). Letf2 = g2;j1;h = g1;j2;h. Then there must exist two morphisms h1 : G . T , h2 : H . T such that the following six properties hold: . .(1)g1;h1 = f1 (i, k).CT [M](c1) (2)g2;h1 = f2 .(3).x . Tb2(x)= b1(x)+|{y . (G \ g2(K))| h1(y)= x}| . . .(4)g1;h2 = f2 . (k, j).CT [M](c2) (5)g2;h2 = f3 . . (6).x . Tb3(x)= b2(x)+|{y . (H \ g2(L))| h2(y)= x}| We define h1,h2 to be h1 = j1;h and h2 = j2;h which already satisfy the following four properties: .. (1) g1;h1 = g1;j1;h = f1 (4) g1;h1 = g1;j2;h = f2 .. (2) g2;h1 = g2;j1;h = f2 (5) g2;h1 = g2;j2;h = f3 We define b2 with respect toproperty(3), suchthatfor all x . T the equation b2(x)= b1(x)+ |{y . (G \ g2(K))| h1(y)= x}| holds.Due toproperty(6) we get the following equation for b3,forwhich weneed toprovethat itholdsforall elements x . T : . b3(x)= b1(x)+|{y . (G \ g2(K))| h1(y)= x}| +|{y . (H \ g2(L))| h2(y)= x}| Weprovethefollowing equation(7) insteadforall x . T , from which we can easilyderive afterwardsthat also(6) holds: . |{y . (G \ g2(K))| h1(y)= x}| + |{y . (H \ g2(L))| h2(y)= x}| . =|{y . (G . \ g2;j2(L))| h(y)= x}| (7) Since the morphisms j1 and j2 are both injective and G . is the pushout object of G and H overthe commongraph K weget that G . = j1(G \ g2(K)). j2(H). Subtracting all elements x . L that are being mapped into H on both sides of 25 .. the equation, wegetthat G . \ g2;j2(L)= j1(G \ g2(K)). j2(H \ g2(L))holds as well.Using thisfact we canprove equation(7) whichholdsfor all x . T : . |{y . (G . \ g2;j2(L))| h(y)= x}| . =|{y . j1(G \ g2(K)). j2(H \ g2(L)) | h(y)= x}| . =|{y . j1(G \ g2(K))| h(y)= x}.{y . j2(H \ g2(L))| h(y)= x}| . =|{y . G \ g2(K)| (j1;h)(y)= x}.{y . H \ g2(L)| (j2;h)(y)= x}| . =|{y . G \ g2(K)| h1(y)= x}.{y . H \ g2(L)| h2(y)= x}| . =|{y . (G \ g2(K))| h1(y)= x}| + |{y . (H \ g2(L))| h2(y)= x}| Using equation(7) we concludethatproperty(6) alwaysholdsfor all x . T : . b3(x)= b1(x)+|{y . (G . \ g2;j2(L))| h(y)= x}| . = b1(x)+|{y . (G \ g2(K))| h1(y)= x}| + |{y . (H \ g2(L))| h2(y)= x}| . = b2(x)+|{y . (H \ g2(L))| h2(y)= x}| Therefore(i, j).CT [M](c1);CT [M](c2)holds as well. 2.Ó . Ó :Let twopairs(i, k) .CT [M](c1) and(k, j).CT [M](c2) be given with i .CT [M](J), k .CT [M](K) and j .CT [M](L) such that i =(f1 : J . T,b1), k =(f2 : K . T,b2)and j =(f3 : L . T,b3). Then in addition there exist two morphisms h1 : G . T and h2 : H . T such thatfor all x . T the two equations b2(x)= b1(x)+|{y . (G \ g2(K))| h1(y)= x}| and . b3(x)= b2(x)+ |{y . (H \ g2(L)) | h2(y)= x}| both hold and the following diagram commutes: c1 : JK c2 : KL .. g1 g2 gg12 JGKHLf1f2.h1.h2f3T To prove that(i, j).CT [M](c1;c2)is satisfied from the properties gained so far, . we need to show that b3(x)= b1(x)+ |{y . (G . \ g2;j2(L))| h(y)= x}| holds and that there exists a morphism h: G . . T such that the following diagram commutes: 26 c1 : JK c2 : KL .. ggg1 g212 J G K H L j1 j2(PO) h1 h2 f1 G . f3 .h T The morphism h: G . . T exists and is unique due to the universal property of pushouts.From the two equationsb2(x)= b1(x)+|{y . (G\g2(K))| h1(y)= x}| . and b3(x)= b2(x)+|{y . (H \ g2(L))| h2(y)= x}| we can derive the following equation which holds for all x . T : . b3(x)= b1(x)+|{y . (G \ g2(K))| h1(y)= x}| +|{y . (H \ g2(L))| h2(y)= x}| Using the results of equation(7) fromthepreviousproofdirection, wedirectly . can conclude that b3(x)= b1(x)+ |{y . (G . \ g2;j2(L))| h(y)= x}| also holds and therefore(i, j).CT [M](c1;c2)holds, which completes this proof. .. Proposition 32. Let the multiply annotated type graph T [M] (over Bn) and the corresponding automaton functor C : Cospan(Graph). Rel for T [M] be mgiven. Then LC = L(T [M]) holds,i.e.for agraph G we have G .L(T [M]) if and only if there exist states i . I .C(.)and f . F .C(.)such that (i, f).C(c), where c: . . G . .. Proof. We will prove the following equality: G .L(T [M]) .. .i . I .C(.), .j . F .C(.):(i, j).C(c) Ó.Ó: Since(c: . . G . .) .L(T [M]) holds, there exists a legal morphism .: G . T and a pair of multiplicities (., u) . M such that . ²Bn(sG) ² u'holds. Let(i, j) be i =(f1 : . . T, 0) . I and j =(f2 : . . T, Bn(sG)). F'which are clearly in the relation C(c), i.e. (i, j) .C(c) since for all x . T the equation Bn(sG)(x)=0+|{y . (G \ g2(.))| .(y)= x}| = |{y . G | .(y)= x}| 'holds by definition and the following diagram commutes: c: .. g1 g2 . .G f1.f2T 27 Ó.Ó: There exists i . I .C(.)and j . F .C(.)with i =(f1 : . . T, 0)and j =(f2 : . . T,b)such that(i, j).C(c)holds.Therefore,there exists apair of multiplicities(., u). M with . ² b ² u and weget that there exists a morphism .: G . T such that the following diagram commutes: c: .. g1 g2 . .G f1..f2T For all x . T the following equation holds: b(x)=0+|{y . (G \ g2(.))| .(y)= x}| = |{y . G | .(y)= x}| = Bn(sG)(x)'From . ² b ² u we can infer that .: G . T is a legal morphism due to the fact that . ²Bn(sG)² u holds as well, and therefore G .L(T [M]). ..'Proposition 33. The category of multiply annotated graphs is closed under intersection. Proof. Let two multiply annotated typegraphs T1[M1]and T2[M2]begiven.Let T1 . T2 be the usual product graph in the underlying category Graph. We now considerthe multiply annotated typegraph(T1 . T2)[N]where the set of annotations N is defined as follows: N = {(., u)| ., u .A(T1 . T1)such that ¹1 :(T1 . T2)[., u]. T1[M1]is legal and ¹2 :(T1 . T2)[., u]. T2[M2]is legal} Therefore for each (., u) . N there exist (.1,u1) . M1 and (.2,u2) . M2 such that the following four properties hold: (T1 . T2)[N] . q.A1 (.)³ .1 A1 (u)² u1 q. ..q.q.q.q.A2 q1 2 ..A2 (.)³ .2 (u)² u2 qq. T1[M1] T2[M2] We will now prove the following equality: L(T1[M1]) .L(T2[M2]) = L((T1 . T2)[N]) .: Let G .L(T1[M1]) .L(T2[M2]). Then there exist two legal morphisms .1 : G[sG,sG] . T1[M1] and .2 : G[sG,sG] . T2[M2]. Due to the universal 28 property of pullbacks in the underlying category Graph, there exists a unique graph morphism . : G . T1 . T2 such that the following diagram commutes: G[sG,sG] '1		 '2  (T1.T2)[N] 1xxqqqqqqqqqqq2&&...........T1[M1] T2[M2] Since .i = ¹i . . with i .{1, 2} is a legal morphism, there exist annotations (.1,u1). M1 and(.2,u2). M2 such that the following inequalities hold: .1 ²A'1 (sG)= A1 .(sG)= A1 (A(sG))² u1 .2 ²A'2 (sG)= A2 .(sG)= A2 (A(sG))² u2 Therefore the pair(A(sG), A(sG))is one of the annotations in N and we can conclude that G .L((T1 . T2)[N]) holds. .: We now assume G .L((T1 . T2)[N]). Then there exists a legal morphism . : G[sG,sG]. (T1 . T2)[N]with an annotationpair(., u). N such that . ² A(sG)² u.For eachsuchpair(., u). N wehavetwo legalmorphisms ¹1 :(T1 . T2)[., u]. T1[M1]and ¹2 :(T1 . T2)[., u]. T2[M2], by construction. We obtain two morphisms .1 : G[sG,sG]. T1[M1]with .1 = ¹1 . . and .2 : G[sG,sG]. T2[M2] with .2 = ¹2 . ., which are legal due to Lemma 22. Therefore we can conclude that G . (L(T1[M1]) .L(T2[M2])). .. In order to show closure under union for annotated type graphs over Bn, we first have a look at the following lemma. Lemma 36. Assume that we are working with annotations over Bn . Let i: A[M] . T [N] and .: G[sG,sG] . T [N] be two legal graph morphisms where i is injective. Let G[sG,sG] (., u) . M be one of the double multiplicities of the . graph A. Whenever B'n(sG) ²Bin(u), we can deduce . yy that there exists a graph morphism . : G . A with A[M ]i T [N] i . . = ., i.e. the diagram commutes. Proof. The morphisms . exists if all elements of the form .(x) with x . G are in the range of i. For such an x wehave1 = sG(x)²Bn(sG)(.(x)), since'Bn(sG)(.(x))isthesumofthesG-annotations ofallpreimages ofx.Furthermore'Bn(sG)(.(x)) ²Bn(u)(.(x)). But Bn(u)(y) =0for all y . T that are not in'i i the range of i, since the empty sum evaluates to 0. But since Bn(u)(.(x))³ 1,i we can conclude that .(x)has a preimage under i. .. In addition, we need the concept of reduction: the reduction operation shifts annotations over morphisms in the reverse direction. 29 Definition 37 (Reduction). Let A be an (annotation) functor. For a mor. phism .: G . G . and a monoid element a .A(G . ) we define the reduction of . a to G as follows: red'(a . )= {a |A'(a)² a . }. In the case of concrete annotations, the reduction operator satisfies the following properties: Lemma 38. Assume that we are working with annotations over Bn. If .: G . H is injective, we obtain the following equality for all x . G: red'(a . )(x)= a . (.(x)) Furthermore, if .: G . G . is injective, it holds that red'(Bn(a))= a for every'a .Bn(G). Proof. Straightforward from the definition of concrete annotations. .. We are now ready to prove closure under union for the concrete case. Since we do work with abstract annotations in the proof, but need the results of the lemmas, one couldgeneralizethis resultto a setting wherethepropertiesstated in Lemma 36 and Lemma 38 hold. Proposition 34. The category of multiply annotated graphs over functor Bn is closed under union. Proof. Let two multiply annotated typegraphs T1[M1]and T2[M2]begiven.Let T1 . T2 be the usual coproduct graph in the underlying category Graph, together with the embedding morphisms i1 : T1 . T1 . T2 and i2 : T2 . T1 . T2: T1[M1] T2[M2] ..r.r.r.r.r.r.ri1 ..rri2 T1 . T2[N] We define the set of annotations N forthe multiply annotated typegraph(T1 . T2)[N]using the following two sets: N1 = { (Bn (.1), Bn (u1)) | (.1,u2). M1}i1 i1 N2 = {(Bn (.2), Bn (u2))| (.2,u2). M2}i2 i2 Finally we define N = N1 . N2. By this definition, we get that for all elements x . T1 andfor all(., u). M there exists(.1,u1). NT1 (M) suchthat Bn (.)(i1(x))= .1(i1(x))andBn (u)(i1(x))= i1 i1 u1(i1(x)). This makesi1 a legal morphism since N1 . N. The same holds for i2 analogously. We will now prove the following equality: L(T1[M1]) .L(T2[M2]) = L((T1 . T2)[N]) 30 .: Let G . (L(T1[M1]) .L(T2[M2])). Then there exists at least one legal morphism .1 : G[sG,sG]. T1[M1]or .2 : G[sG,sG]. T2[M2]. We assume that G .L(T1[M1]). Let . : G[sG,sG] . (T1 . T2)[N] be the composed morphism of i1 and .1 with . = i1 . .1. Then . is legal due to Lemma 22 and therefore G .L((T1 . T2)[N]) holds. The proof for the case where G .L(T2[M2]) works in the same way. .:We now assume G .L((T1 .T2)[N]). Then, there exists a legal morphism . : G[sG,sG] . (T1 . T2)[N] with an annotation (., u) . N such that . ² Bn(sG) ² u.For each(., u). N, we know that the pair belongs to N1 or N2.. Assume that (., u) . N1. Then we know that there exists (.1,u1) . M1 such that . = Bn (.1), u = Bn (u1). Hence Bn(SG)² u = Bn (u1). From Lemma 36i1 i1 i1 it follows that there exists a graph morphism .1 : G . T1 with . = i1 . .1 such that the following diagram commutes in the underlying category Graph: G[sG,sG] T1[M1] 1xx &&&& i1...........T2[M2] qi2 (T1 . T2)[N ] We needtoprovethat.1 isa legalgraphmorphism inthecategoryofmultiply annotatedgraphs.Weget that Bn(sG)= Bn (sG)= Bn (Bn (sG))and since i1i1 .1 i1 1 is injective, the following inequality holds due to the fact that red. is monotone and red'(Bn(a)) = a holds for every a .Bn(G), whenever . is injective (cf.'Lemma 38): Bn (.1)²Bn(sG) ²Bn (u1)i1 i1 .Bn (.1)²Bn (Bn (sG)) ²Bn (u1)i1 i1 1 i1 . redi1 (Bn (.1))² redi1 (Bn (Bn (sG)))² redi1 (Bn (u1))i1 i1 1 i1 . .1 ²Bn 1 (sG) ² u1 Therefore .1 : G[sG,sG]. T1[M1]is a legal morphism and we can conclude that G .L(T1[M1]). For a legal morphism . : G[sG,sG] . (T1 . T2)[N] with a pair (., u) . N2 we get a similar proof which shows that G .L(T2[M2]). Summarizing, in all cases G . (L(T1[M1]) .L(T2[M2]))holds. 31 B Extended Example: Annotated Type Graphs Inorderto illustratetheuseof annotated typegraphsinapplications,wemodel a client-server scenario with the following specification: Ð There exists exactly one server. Ð An arbitrary number of users can connect to the server, even using multiple connection sessions at the same time. Ð There exists one user with special administrative rights. Ð At least one user is always connected to the server. Ð The server can host an arbitrary number of files from which at most one can be edited at the same time. The abovescenariocanbe modelled using an annotated typegraph T1[., u](see below). We will use the following edge labels: A-labeled loops for administrative rights, C-labeled edges for connections between users and the server and E-labeled edges which are pointing to the file that is currently edited. We now extend the requirements of our specification: Ð The user with the administrative rights is always connected to the server. Ð There has to be at least one file on the server. We use the annotatedtypegraphT2[. . ,u . ],depictedbelow to modelthe extended scenario. A [1, 1] A [1, 1] C [1, 1] E [0, 1] C [1,m] E [0, 1] T2[. . ,u . ]= [1, 1] [1, 1] [1,m] [1,m] [1, 1] [0,m] T1[., u]= C [0,m] [0,m] Since the second scenario is more restrictive than the first, there exist graphs in L(T1[., u]), which do not fulfil the additional requirements of the extended specification. A For instance the graph G shown to the right is such a model, which describes that there exists a user with administrative rights but he is not connected to the server. Instead there C is another user which is currently connected. However, it holds that that L(T2[. . ,u . ]) .L(T1[., u]), since we can easily find a legal graph morphism .: T2[. . ,u . ]. T1[., u]. 32 