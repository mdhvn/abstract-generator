A System-Design Methodology: Executable-Specification RefinementDaniel D. Gajski, Frank Vahid and Sanjiv Narayan Department of Information and Computer Science University of California, Irvine, CA, 92717 Abstract As methodologies and tools for chip-level design mature, design effort becomes focused on increasingly hzgher levels of abstraction. We present a methodology and tool for system-level specification, design and re- finement that result in an executable specification for each system component. The specification for each component can then be synthesized into hardware or compiled to software. We highlight advantages of the proposed methodology compared to current practice. Introduction The focus of design effort on higher levels of abstraction has led to the need for a system-level methodology and supporting tools. There are two main steps in system-level design. The first is func-tionalzty speczficatzon, which is the task of describing the desired system behavior in some form. The sec- ond is system design, which is the task of implement- ing this functionality with system components such that design constraints are satisfied. Example sys- tem components include standard processors and mi- crocontrollers, memories, buses, and custom ASICs. The domain of these two steps is shown in Figure 1. The result of system design is a set of system compo- nents, each with its own functional specification. Im- plementation of each component follows. A standard component requires software compilation of the func- tional specification into machine code, whereas custom components require synthesis of the specification into register-transfer structure. The first task is accom- plished with standard compilers while the second one uses high-level and logic synthesis. There are two very different system-level design ap- proaches in current practice. In one approach, the system’s functionality is first implemented with inter- connected register-transfer or gate-level objects, and tThis work was supported by the SRC (grant #91-DJ-146), NSF(grant #MIP 8922851-01) and California Micro(grant #91-040, #91-041). Funcfionality specification I + ISpecification System Design t Memory Component implementation t detailed bus protocol Figure 1: System-level domain this structure is then partitioned among system com- ponents. However, once structure is obtained only minor changes can be made to the system’s perfor- mance through introduction of redundant objects or through repartitioning. More substantial changes re- quire knowledge of high-level functional and timing in- formation, but such information can not be discerned from the structure. A second drawback to this ap- proach is it doesn’t consider software implementations. In the other approach, the system’s functionality is first partitioned among system components, and each component is then implemented as structure or as soft-ware, depending on the component type. While over- coming the drawbacks of the structure-first approach, current practice of this approach involves mostly in- formal and manual techniques. The functionality is informally specified using a natural language such as English, and system design is done manually using mental or hand-calculated estimations for quality met- rics such as performance, size, and power. Drawbacks of such techniques include the lack of early functional verification, the lack of good feedback with regards to quality metrics that result from design decisions, the lack of automated tools to reduce design time, and 458 1066-1409/94$3.000 1994IEEE the lack of good documentation of functionality and design decisions to aid in concurrent design and in re- design. Several research efforts have focused on overcom- ing one or more of these drawbacks. Simulation en- vironments have been developed to encourage early system simulation of hardware and software compo- nents for functional verification [l, 21. An architec- tural template and tools environment for rapid proto- typing have also been suggested [3]. Functional par- titioning approaches have been introduced for multi- ple custom chips [4, 51, and for multiple processors [I?]. Issues for functional partitioning among hardware and software components have been discussed [7], and prototype partitioning systems have been developed [5,81. Frameworks have been proposed to support the process of controlling and interfacing various system- design tools [9]. The methodology and tool we present can be used in conjunction with the simulation, prototyping, and framework environments described above. Our work differs from other previous efforts in several key points. First, we handle exploration of various implemen- tations of the three aspects of functionality, namely behavior, data, and communication, rather than fo- cusing on behaviors alone as in most previous work. Second, our technique is applicable to a variety of system-component technologies, not just a fixed set of hardware or software components of one technol- ogy. The above two points provide a seamless explo- ration of system-design options, which includes hard- ware/software codesign. Third, the end result of our approach is a re-fined speczficatzon in which interconnected system-components are functionally specified, permitting fur- ther verification and encouraging concurrent design. Fourth, we use a new model (PSM) for specification that can describe both hardware and software func- tionality, at varying levels of abstraction, in a uniform manner. This model differs from previous ones which were well suited for either software or hardware but not both. In this paper, we present our system-level method- ology. It is highlighted in Figure 2, where the boxed items represent a replacement of informal and manual techniques with well-defined and automatable ones. We first describe system specification and introduce our PSM model. We then define and describe the major system-design tasks, as well as a suggested or-dering of those tasks. We provide a real example, and describe an environment to support the methodology. Design Designrepresentation Tasks evaluation Functionality specificafion Executable Design SimulationRefinement Executable specification I Rules-of-thumb HW synthesis Component metrics Component implementafion sw compilation Wout metrics SimulationINetlists Layouts Program code Figure 2: Proposed system-level methodology 2 Executable specification and PSM We use an executable specification rather than a natural language to specify system functionality. An executable specification is one which captures the functionality of the system in a machine-readable and simulatable form. It has several advantages over a natural language. First, simulation enables early ver- ification of the correctness of the system's intended functionality. Second, the specification may serve as an input to synthesis tools, resulting in significant,ly reduced design times. Third, the specification serves as documentation by providing a precise description of intended functionality. Many languages have been used for executable specification, including VHDL, Verilog, C, and Stat- echarts. Such languages are used to capture coni- mon conceptual models such as finite-state machines (FSM), FSMs with complex expressions, hierarchi-cal and concurrent FSMs, dataflow diagrams, Petri- nets, and communicating sequential processes. Un-fortunately, these conceptual models are not adequate for concisely describing all of the characteristics of a common class of systems referred to as embedded systems. These characteristics include: prograni-ming constructs, state-transitions, sequential and con- current behavior decompositions, and exceptions. To overcome this limitation, we developed a new model called program-state machines. Program-state machines (PSM) [lo] are essen- tially a combination of the hierarchical finite-state ma- chine and programming language paradigms. A sys-459 tem is specified as a hierarchy of program-states, where each program-state represents a mode of computation and may include standard programming declarations such as variables, types, and subroutines. At any given time only a subset of program-states are active, i.e. are actively carrying out their computations. A single root program-state represents the entire system and is always active. A program-state may either be a composite program-state or a leaf program-state. A compos- ite program-state may be hierarchically decomposed either into a set of concurrent program-substates (all program-substates are active when the program- state is active), or into a set of sequential program-substates (only one of the program-substates is active at a time when the program-state is active). A se- quentially decomposed program-state contains a set of transition arcs to represent the sequencing between the program-substates. There are two types of tran- sition arcs. A transztzon-on-completzon arc (TOC) is traversed when the source program-substate has com- pleted its computation and the associated arc condi- tion evaluates to true. A transztzon-zmmedaately arc (Ti)is traversed immediately when the arc condi- tion becomes true, regardless of whether or not the source program-substate has completed its computa- tion. A leaf program-state is at the bottom of the be- havioral hierarchy and has its computation described using programming language statements. The PSM model supports all embedded-system characteristics in an elegant manner. In addition, as the system is refined, the programming constructs can br used to describe portions destined for software im- plementation while the state-transitions describe por-tions destined for hardware implementation, all with a single uniform representation that eliminates the need for multiple languages. Since no language currently exists that supports all the PSM characteristics, we dweloped a VHDL front-end language called Spec- Charts [ll]. Our subsequent system-design methodology is not strictly dependent on use of the PSM model and Spec- Charts. Other languages may be used to capture the PSM model, with some extra effort. However, PSM and Speccharts are in closest accord with our system- design methodology, and yield the most concise and readable specifications. 2.1 System design System design is the task of mapping the function- ality, as captured in an executable specification, to some set of system components such that design con- straints on parameters such as monetary cost, per- formance, and power are satisfied. Our approach to system design consists of three well-defined tasks on Variables Functional objects Allocation Memories ; Systemdes@n tasks Partitioning Variableslo memories Refinement : Address assignment Behaviors Channels I Processors Buses ; Behavionto pr-som. Channelsto buses ! InlelfaChg i Arbitration/prdocols I Figure 3: System-design tasks three classes of functional objects, as summarized in Figure 3. The three classes of functional objects that comprise any executable specification are variables, behaviors, and channels. Variables store data, be- haviors transform data, and channels transfer data between behaviors. In our terminology, a behavior is a non-trivial algorithmic-level computation that to- gether with other behaviors describe all system actions (identical to the “task” concept described in [7]). It corresponds to a block of statements in the specifica- tion such as a loop body, procedure, or process. For each of these objects there are three tasks to be per- formed: allocation, partitioning, and refinement. Allocation adds system components to the design. One class of system component consists of memories, such as RAMS, ROMs, register-files, and registers. Memories are used to store scalar and array variables. Another class of component consists of standard pro- cessors and microcontrollers as well as custom ASIC “processors”. These standard/custom processors are used to implement behaviors. A third class of ‘‘COITI-ponent” consists of physical buses. Buses are used to implement communication channels. Partitioning maps each class of functional objects to allocated components. Variables are mapped to memories, behaviors are mapped to standard/custom processors, and channels are mapped to buses. Each mapping is many to one. Standard partitioning algo- rithms, such as clustering or simulated annealing, can be applied. Clustering may use any of various close- ness criteria [12]. For behaviors, common criteria in- clude interconnection, communication, sequentiality, and hardware sharability. For variables and for chan- nels, common criteria include sequential access, com- mon accessors, and width similarity. Refinement adds new behaviors to maintain cor- rect functionality for a given allocation and parti- tioning. Variables partitioned among memories re-quire memory address translation. Behaviors sepa- rated among components must be modified to main- tain correct communication. Channels mapped to buses require interface synthesis to determine commu- nication protocols, and arbiter synthesis to resolve any simultaneous bus requests. A refined specification is then generated consisting of a set of interconnected system-components, each functionally specified. 460 2 Vartable-to-menwry pannbnlng 3 usa allocation 4 Channel-to-bus paflNoning 5 Customktandard procasxrr allccation 6 BBhavmr-10-P-r partnbning 7 lnletiam synlhesls 9 ArMlervnlhesis Executable spenlicatlon Conponent im!a”tabon tLt Sd(ware Hardware Figure 4: One possible ordering of tasks There is no fixed ordering of the system-design tasks. One ordering which we have found leads to good results is shown in Figure 4.After the function- ality is specified, large variables are mapped to mem- ories such that variables which satisfy closeness crite- ria are mapped to the same memory. Channels are mapped to buses in a similar manner. Then proces- sor or ASIC components are allocated and behaviors are partitioned among those components. Variable or channel repartitioning may follow in order to further improve the design. Interface and arbiter synthesis are pt?rformed to complete the functional specification of each component. Throughout the entire process, allocation and par- titioning tasks are guided by estimations of design quality metrics such as area, performance, pins, and power. Accurate yet fast estimation techniques are a subject of intense research; some results for both hard- ware and software implementations are described in [13, 14, 15, 161. The estimations are incorporated into an objective function used for design evaluation. A common objective function is one which favors designs with the smallest amount of constraint violations. To further evaluate design decisions, a refined spec- ification can be generated and simulated between any tasks during the design process. The resulting system components can be imple- mented with either automated or manual techniques. Since the components are defined as an executable specification, synthesis or compilation follow very nat- urally. 3 Example Let us consider as a design example an interac- tive television processor (ITVP). The system captures video frames and displays them as still pictures while audio is played. A user can interact by selecting menu RF ouput to N Figure 5: The ITVP’s environment items via the TV remote control, resulting in an ap- propriate new video frame and accompanying audio. Such systems are common in hotels, stores, and more recently in homes with cable TV. They can be used to take a video tour of a hotel, shop through a video catalog, or even to perform banking transactions or make airline reservations. The system resides in a box adjacent to a television set, similar to a box for cable TV. A diagram of the overall system is found in Fig- ure 5, with only certain data flows shown. The core of the ITVP is a digital subsystem, the design of which will be our focus. The main behaviors and data objects for the digital subsystem are shown in Figure 6. The actual system consists of 32 behaviors and 69 data objects derived from 860 lines of VHDL code, but only the large or important objects are shown. The system contains behaviors called CaptureAudio and GenerateAudio to capture and then generate several thousand succes- sive audio bytes (i.e. a frame), using two arrays audio1 and audio2. Likewise, the CaptureGeneratevideobe-havior and video array capture and generate video frames. A fonts array indicates which of the 16x16 pixels should be illuminated for each of the 128 supported ASCII characters. A screen-chars ar-ray indicates which ASCII character, if any, should be displayed in each of the 30x30 screen positions. OverlayCharacters reads the screen-characters and fonts arrays and indicates to the video generator when to override a video pixel with a white pixel so that a white character will appear on the screen. Behav-ior CaptureAVCmd and variable au-cmd capture an encoded command that appears at the start of ev- ery audio or video frame, where the command iri- dicates how to handle the frame. Finally, there is a behavior ProcessRemoteButtons to respond to buttons pressed on the remote control, a behavior ProcessAVCmd to handle the encoded audio/video command, and a behavior ProcessMainCmds to re- spond to commands issued by the main computer. 461 audio-in audio-out I II 8 I I1 IiCaptureGeneratevideo ;I, ,I iI CaptureAVCmd] I I I II av-cmd(21 I I ProcessAVCnd ProcessRemoteButtons I II I II ProcessMainCmds OverlayCharacters II I Figure 6: One possible design for the ITVP After the specification and system-design steps of our methodology, the system components are de-fined and the system may be summarized in “block-diagram” form, a form familiar to most design-ers. Such a block-diagram is shown in Figure 6 for our example. The system is implemented with SIX components: three memories, two ASICs, and a processor. Each of the behaviors and vari-ables is mapped to exactly one of these compo-nents. The Memory1 component stores both the audio1 and audio2 arrays, while hfemory2 stores the video array. Memory3 stores both the fonts array and the screen-chars array. ASZCl imple-nients the CaptureAudio and GenerateAudio be-haviors, ASIC2 implements CaptureGeneratevideo behavior as well as the CaptureAVCmd behav-ior and the av-cmd variable, and Processor im-plements the ProcessAVCmd, ProcessMainCmds, ProcessRemoteButtons and OverlayCharacters be-haviors. Note that there is a single bus, busl, to which scveral channels have been mapped, including hehav-ior accesses to av-cmd, fonts and screen-chars. Let us consider the decisions made in the example design. The audio and video arrays were stored in sep-arate memories because they must be output simulta-neously. Storing them in the same memory would have required multiplexing accesses to them which in turn would have violated minimum audio/video output-rate constraints. The audio and video capture and generate behaviors were implemented on ASICs be-cause software implementations would not have met input and output rate constraints. The audio and video behaviors appear on different ASICs because they would not both fit on a single ASIC containing 20,000 gates. An ASIC was used to store the av-cmd variable because the command must he captured ini-mediately, and such immediate capture would ha\e been difficult to implement on the processor. The vari-able could have been stored on either ASIC. The fonts and screen-chars arrays are not accessed concurrently so they were mapped to a single memory without loss of performance. The behaviors in the processor do not require very fast performance, so they can be imple-mented in software without violating constraints, evcn though the behaviors are specified as executing COII-currently but are implemented sequentially (actually they are interleaved with one another). The above block diagram represents just one of many possible ITVP designs. For example, the two ASIC components can be replaced by a single, 1argt.r ASIC. Alternatively, we can use an ASIC technology with different cost and performance characteristicr. We can even use a microcontroller rather than a pro-cessor to lower costs. For each possible set of coni-ponents, there are numerous alternative mappings of behaviors and variables to those components. To generate a specification for each component, the processor behaviors must be refined into a single sequential behavior, and interfaces must be synthe-sized between each behavior and variable which re-quire data transfer between components. The exam-ple demonstrates the need and usefulness of the allo-cation, partitioning, and refinement tasks as defined in our methodology. 4 The SpecSyn environment A set of tools to support our methodology is being implemented as the SpecSyn system-design enviroli-ment. It consists of partitioners [17] which support several algorithms including clustering, group migra-tion, and simulated annealing; estimators [13, 141 for the quality metrics of execution-time in hardware or software, hardware area, software instruction and data memory size, and pins; and prototype tools to synthe-size arbiters and interfaces [18]. The partitioners, es-timators, and interface/arbiter tools are implementcd in C with 16000, 19000, and 8000 lines of code, rc’-spectively. Routines for internal representation of the specification require 30,000 lines of code. SpecSyn has been released to over 10 companies and a new version is due for distribution in the first quarter of 1994. 462 i SpecSyn jt ............................................................... Figure 7: The SpecSyn system-design environment Conclusion We have applied the methodology with the SpecSyn environment on several examples, including a medi-cal instrument for measuring bladder volume, a fuzzy-logic controller, a RISC signal processor, an interac- tive TV system, a microwave-transmitter controller, and an answering machine. Design quality is compa- rable with manual designs and design-time is up to an order of magnitude less. Numerous manual alloca- tions and partitionings and hundreds of automatically generated ones can be evaluated in just minutes. There are several advantages to using a system-level methodology that refines an executable specification through the system-design tasks of allocation, parti- t ioning, and refinement. First, early functional ver- ification through simulation is possible, which min- imizes the occurrence of time-consuming functional changes later in the design process. Second, the result- ing system-component executable specifications are precise so they enable concurrent design and mini- mize integration problems. Third, the specification is machine-readable so automation tools can be used to reduce overall design time and estimators used to rapidly explore many more possible designs. Fourth, the well-defined system tasks combined with the exe- cutable specification lend themselves to excellent doc- umentation of system-design decisions and intended functionality, which is especially important for re-design. We envision a conceptualization environment that allows designers to quickly explore and evaluate po- t,ential designs. This requires work on three parts of such an environment: (1) a component base with VHDL models for different technologies, (2) fast es- timators of quality metrics for different architectural styles and technologies (e.g. custom layout, gate- arrays, FPGA’s, and standard components), and (3) an appropriate human interface for display of quality rnetrics and different user views. The SpecSyn envi- ronment is a first step in this direction. References A. Kalavade and E. Lee, “A Hardware/Software Codesign Methodology for DSP Applications,” in IEEE Desagn €4 Test, 1993. R. Gupta, C. Coelho, and G. DeMicheli, “Synthesis and Simulation of Digital Systems Containing Inter- acting Hardware and Software Components,” in DAG‘, pp. 225-230, 1992. M. Srivastava and R. Brodersen, “Rapid-Prototyping of Hardware and Software in a Unified Framework,” in ICCAD, pp. 152-155, 1992. E. Lagnese and D. Thomas, “Architectural Partition- ing for System Level Synthesis of Integrated Circuits,” IEEE Trans. on CAD, July 1991. R. Gupta and G. DeMicheli, “Hardware-Software Cosynthesis for Digital Systems,” in IEEE Desagn €4 Test, pp. 29-41, October 1993. S.Prakash and A. Parker, “Synthesis of Applicatioii- Specific Multiprocessor Architectures,” in DA(7, pp. 8-13, 1991. D. Thomas, J. Adams, and H. Schmit, “A Model and Methodology for Hardware/Software Codesign,” in IEEE Design €4 Test, pp. 6-15, 1993. R. Ernst, J. Henkel, and T. Benner, “Hardware-Software Cosynthesis for Microcontrollers,” in IEl’E Desagn €4 Test, pp. 64-75, December 1994. M. Jacome and S. Director, “Design Process Manage- ment for CAD Frameworks,” in DAG, pp. 500-505, 1992. D. Gajski, F. Vahid, and S. Narayan, “SpecCharts: A VHDL Front-End for Embedded Systems.” UC Irvine TR 93-31,1993. S.Narayan, F. Vahid, and D. Gajski, “System Speci- fication with the Speccharts Language,” in IEEE De- sagn & Test, Dec. 1992. D. Gajski, J. Gong, F. Vahid, and S. Narayan, “The SpecSyn Design Process and Human Interface.” UC Irvine TR 93-3,1993. S. Narayan and D. Gajski, “Area and Performance Estimation from System-Level Specifications.” UC Irvine TR 92-16,1992. J. Gong, D. Gajski, and S. Narayan, “Software Es-timation from Executable Specifications,” in Journal of Computer and Software Eng., to appear. W. Ye, R. Ernst, T. Benner, and J. Henkel, “Fast Timing Analysis for Hardware-Software Co-Synthesis,” in ICCD, pp. 452-457, 1993. F. Vahid, S. Narayan, and D. Gajski, “Constant- Time Cost Evaluation for Behavioral Partitioning.” UC Irvine TR 92-29,1992. F. Vahid and D. Gajski, “Specification Partitioning for System Design,” in DAG, 1992. S. Narayan and D. Gajski, “Synthesis of System-LevelBus Interfaces,” in EDAC, 1994. 463 